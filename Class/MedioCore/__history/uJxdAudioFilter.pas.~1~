unit uJxdAudioFilter;

interface

uses
  Windows, SysUtils, BaseClass, MMSystem, DirectShow9, ActiveX;

type
  TAudioChannelStyle = (asAll, asLeft, asRight);
  TxdAudioChannelFilter = class(TBCTransInPlaceFilter)
  public
//    FIndex: Integer;
    AudioChannelStyle: TAudioChannelStyle;
    
    constructor Create;
    destructor Destroy; override;
    
    function CheckInputType(mtIn: PAMMediaType): HRESULT; override;
    function Transform(Sample: IMediaSample): HRESULT; override;
  private
    procedure PCMWaveData(Buf: PByte; Length: Integer; P: PWaveFormatEx);
//    procedure MyTestDrawWaveData(Buf: PByte; Length: Integer; P: PWaveFormatEx);
  end;

implementation
//
//uses
//  MainForm, Graphics;

const
  CtAudioChannelFilterName = 'Audio Filter';
  CtAudioChannelGUID : TGUID = '{3F06D3B4-F953-463B-BF42-FE835BEE9AB2}';

function TxdAudioChannelFilter.CheckInputType(mtIn: PAMMediaType): HRESULT;
const
  WAVE_FORMAT_IEEE_FLOAT      = $0003;
  WAVE_FORMAT_DOLBY_AC3_SPDIF = $0092;
var
  P: PWaveFormatEx;
begin
  Result := VFW_E_TYPE_NOT_ACCEPTED;
  if not IsEqualGUID(mtIn^.formattype, FORMAT_WaveFormatEx) then
    Exit;
  P := PWaveFormatEx(mtIn^.pbFormat);
  if (P^.nChannels > 2) and (P^.wFormatTag <> WAVE_FORMAT_EXTENSIBLE) then
  begin
    Result := VFW_E_INVALIDMEDIATYPE;
    Exit;
  end;
  if IsEqualGUID(mtIn^.majortype, MEDIATYPE_Audio) and (P^.wBitsPerSample in [8, 16, 24, 32]) and
    ((P^.wFormatTag = WAVE_FORMAT_PCM) or (P^.wFormatTag = WAVE_FORMAT_IEEE_FLOAT) or
    (P^.wFormatTag = WAVE_FORMAT_DOLBY_AC3_SPDIF) or (P^.wFormatTag = WAVE_FORMAT_EXTENSIBLE)) then
    Result := S_OK;
end;

constructor TxdAudioChannelFilter.Create;
var
  hr: HRESULT;
begin
  inherited Create(CtAudioChannelFilterName, nil, CtAudioChannelGUID, hr);
  AudioChannelStyle := asAll;
//  FIndex := 0;
end;

destructor TxdAudioChannelFilter.destroy;
begin
  inherited;
end;

//procedure TxdAudioChannelFilter.MyTestDrawWaveData(Buf: PByte; Length: Integer; P: PWaveFormatEx);
//var
//  I, J, K, B: Word;
//  L, R, X, N, L1, R1, T: Cardinal;
//  Rt: TRect;  
//  PTemp: PInteger;
//begin
//  I := 0;
//  X := 0;
//  with frmPlayer do
//  begin
//    Rt.Left := 0;
//    Rt.Top := 0;
//    Rt.Right := Width;
//    Rt.Bottom := 300;
//    InvalidateRect( Handle, @Rt, True);
//  end;
//  L := 0;
//  R := 0;
//  N := 0;
//  T := 0;
//  
//  B := P.wBitsPerSample shr 2;
//  K := B shr 2;
//  for I := 0 to Length - 1 do
//  begin
//    if I mod B = 0 then
//    begin
//      L1 := 0;
//      R1 := 0;
//      for J := 0  to B shr 1 - 1 do
//      begin
//        Inc(L1, PByte(Integer(Buf) + I + J)^);
//        Inc(R1, PByte(Integer(Buf) + I + J + K + 1)^);
//      end;
//      L1 := L1 div (B shr 1);
//      R1 := R1 div (B shr 1);
//      
//      Inc( L, L1 );
//      Inc( T );
//      if X mod 10  = 0 then
//      begin
////        OutputDebugString( PChar('L: ' + IntToStr(L) + '  R: ' + IntToStr(R)) );
////        L := L mod 255;
////        R := R div 3;
//        L := L div T;
//        L := L mod 255;
//        T := 0;
//                
//        with frmPlayer do
//        begin   
//          Canvas.Pen.Width := 1;
////          if Canvas.Handle <> 0 then
//          begin
//            Canvas.Pen.Color := RGB(255, 0, 0);
//            Canvas.MoveTo( N, 0 );
//            Canvas.LineTo( N, L );
////            Canvas.Pen.Color := RGB(0, 0, 255);
////            Canvas.MoveTo( N, 100 );
////            Canvas.LineTo( N, R + 100 );
//          end;
//        end;
//        Inc( N );
//        L := 0;
//        R := 0;
//      end;
//      Inc( X );
//    end;
//  end;
//  PTemp := Pointer(Buf);
//  while I < Length div 4 do
//  begin
//    L := PTemp^ mod 100;
//    Inc( PTemp );
//    R := PTemp^ mod 100;
//    if R < 0 then
//      OutputDebugString( 'xx' );
//    Inc( I, 4 );
//
//    with frmPlayer do
//    begin   
//      if Canvas.Handle <> 0 then
//      begin
//        Canvas.Pen.Color := RGB(255, 0, 0);
//        Canvas.MoveTo( X, 100 );
//        Canvas.LineTo( X, L );
//        Canvas.Pen.Color := RGB(0, 0, 255);
//        Canvas.MoveTo( X, 100 );
//        Canvas.LineTo( X, R + 100 );
//      end;
//    end;
//    Inc( X );
//  end;
//end;

procedure TxdAudioChannelFilter.PCMWaveData(Buf: PByte; Length: Integer; P: PWaveFormatEx);
var
  I, J, K, B: Word;
//  nCount: Integer;
begin
//  MyTestDrawWaveData(Buf, Length, P);
//  nCount := 0;
//  B := P.wBitsPerSample shr 2;
//  K := B shr 2;
//  for I := 0 to Length - 1 do
//  begin
//    if I mod B = 0 then
//    begin
//      for J := 0  to B shr 1 - 1 do
//      begin
//        PByte(Integer(Buf) + I + J)^ := PByte(Integer(Buf) + I + J)^ div 2;
//        PByte(Integer(Buf) + I + J + K + 1)^ := PByte(Integer(Buf) + I + J + K + 1)^ div 2;
////        Inc( nCount, 
////          (PByte(Integer(Buf) + I + J + K + 1)^ + PByte(Integer(Buf) + I + J)^) div 2 );
////        Inc( nCount, PByte(Integer(Buf) + I + J)^ );
//      end;
//    end;
//  end;

//  nCount := nCount div Length div (B shr 1);

//  with frmPlayer do
//  begin
//    Canvas.LineTo( FIndex, nCount );
//    Inc(FIndex );
//    if FIndex > Width then
//    begin
//      FIndex := 0;
//      Canvas.Pen.Color := Random( $FFFFFF );
//    end;
//  end;
//  nCount := nCount div 2;
//  OutputDebugString( PChar(IntToStr(nCount) ));
    
  if (AudioChannelStyle = asAll) or (P.nChannels = 1) or (not P.wBitsPerSample in [8, 16, 24, 32]) then Exit;
  try    
    B := P.wBitsPerSample shr 2;
    K := B shr 2;
    for I := 0 to Length - 1 do
    begin
      if I mod B = 0 then
      begin
        for J := 0  to B shr 1 - 1 do
          if AudioChannelStyle = asLeft then
            PByte(Integer(Buf) + I + J + K + 1)^ := PByte(Integer(Buf) + I + J)^
          else
            PByte(Integer(Buf) + I + J)^ := PByte(Integer(Buf) + I + J + K + 1)^;
      end;
    end;
  except
  end;
end;

function TxdAudioChannelFilter.Transform(Sample: IMediaSample): HRESULT;
var
  Buf: PByte;
begin
  Result := S_OK;
  try
    Sample.GetPointer(Buf);
    PCMWaveData(Buf, Sample.GetActualDataLength, FInput.CurrentMediaType.MediaType.pbFormat);
  except
    Result := S_FALSE;
  end;
end;


end.

